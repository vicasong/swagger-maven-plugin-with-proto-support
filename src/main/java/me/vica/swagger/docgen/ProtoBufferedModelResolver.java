package me.vica.swagger.docgen;

import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.protobuf.DescriptorProtos;
import com.google.protobuf.Descriptors;
import com.google.protobuf.Message;
import io.swagger.converter.ModelConverter;
import io.swagger.converter.ModelConverterContext;
import io.swagger.jackson.ModelResolver;
import io.swagger.models.Model;
import io.swagger.models.ModelImpl;
import io.swagger.models.properties.*;
import io.swagger.util.AllowableEnumValues;
import io.swagger.util.Json;
import io.swagger.util.PrimitiveType;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.lang.reflect.Method;
import java.util.*;
import java.util.concurrent.ConcurrentSkipListMap;
import java.util.concurrent.ConcurrentSkipListSet;
import java.util.stream.Collectors;

/**
 * 支持Protobuf的模型解析器
 *
 * @author vicasong
 * @since 2019-02-15 15:24
 */
public class ProtoBufferedModelResolver extends ModelResolver {

    private static Logger LOGGER = LoggerFactory.getLogger(ProtoBufferedModelResolver.class);
    // 类名对应模型
    private Map<String, Model> protoModelMap = new ConcurrentSkipListMap<>();
    // 类名对应描述
    private Map<String, Descriptors.Descriptor> descriptorMap = new ConcurrentSkipListMap<>();
    // 父类对应关联类型
    private Map<String, Set<String>> refModelMap = new ConcurrentSkipListMap<>();
    private ObjectMapper _mapper;
    // 当前解析的父类
    private ThreadLocal<String> parentClass = new ThreadLocal<>();

    public ProtoBufferedModelResolver() {
        this(Json.mapper());
    }

    public ProtoBufferedModelResolver(ObjectMapper mapper) {
        super(mapper);
        _mapper = mapper;
    }

    public Model resolve(JavaType type, ModelConverterContext context, Iterator<ModelConverter> next) {
        if (type.isEnumType() || PrimitiveType.fromType(type) != null) {
            return null;
        }
        // Protobuf 实体解析
        if (Message.class.isAssignableFrom(type.getRawClass())) {
            return resolveProtobuf(type, context);
        }
        // 否则使用默认解析操作
        return super.resolve(type, context, next);
    }

    /**
     * 解析Protobuf模型
     *
     * @param type  实体类型
     * @param context   模型转换器上下文
     * @return  模型
     */
    @SuppressWarnings("WeakerAccess")
    protected Model resolveProtobuf(JavaType type, ModelConverterContext context) {
        // Couple of possibilities for defining
        String name = _typeName(type);

        if ("Object".equals(name)) {
            return new ModelImpl();
        }
        Class clazz = type.getRawClass();
        String className = clazz.getName();
        Descriptors.Descriptor descriptor = null;
        if (descriptorMap.containsKey(className)) {
            descriptor = descriptorMap.get(className);
        } else {
            try {
                @SuppressWarnings("unchecked")
                Method method = clazz.getDeclaredMethod("newBuilder");
                Message.Builder builder = (Message.Builder) method.invoke(null);
                descriptor = builder.getDescriptorForType();
                descriptorMap.put(className, descriptor);
            } catch (Exception e) {
                LOGGER.warn("Resolve type failure: " + clazz, e);
                return null;
            }
        }
        return readProtoMessageModel(descriptor, context);
    }

    /**
     * 读取Protobuf描述模型
     *
     * @param descriptor    Protobuf定义描述
     * @param context   模型转换器上下文
     * @return  模型
     */
    private Model readProtoMessageModel(Descriptors.Descriptor descriptor, ModelConverterContext context) {
        Class currentType = readClassOfDescriptor(descriptor);
        String className = currentType.getName();
        String name = descriptor.getFullName();
        String parentClassName = parentClass.get();
        if (parentClassName != null && !className.equals(parentClassName)) {
            refModelMap.computeIfAbsent(parentClassName, key -> new ConcurrentSkipListSet<>())
                    .add(className);
        }
        Model model = null;
        if (protoModelMap.containsKey(className)) {
            model = protoModelMap.get(className);
        } else {
            List<Property> props = new ArrayList<>();
            // 模型定义
            model = new ModelImpl().type(ModelImpl.OBJECT).name(name)
                    .description("This is generated by protobuf.");
            parentClass.set(className);
            try {
                for (Descriptors.FieldDescriptor fieldDescriptor : descriptor.getFields()) {
                    // 字段读取
                    Property property = readProtoProperty(fieldDescriptor, context);
                    props.add(property);
                }
            } finally {
                parentClass.remove();
            }
            // 字段排序
            props.sort(getPropertyComparator());
            Map<String, Property> modelProps = new LinkedHashMap<>();
            for (Property prop : props) {
                modelProps.put(prop.getName(), prop);
            }
            model.setProperties(modelProps);
            protoModelMap.put(className, model);
        }
        JavaType javaType = _mapper.constructType(currentType);
        context.defineModel(name, model, javaType, null);
        if (refModelMap.containsKey(className)) {
            // 关联类型处理
            for (String refClassName :refModelMap.get(className)) {
                Descriptors.Descriptor refDesc = descriptorMap.get(refClassName);
                readProtoMessageModel(refDesc, context);
            }
        }
        return model;
    }

    /**
     * 读取Protobuf定义描述对应类
     *
     * @param descriptor    Protobuf定义描述
     * @return  类
     */
    private Class readClassOfDescriptor(Descriptors.Descriptor descriptor) {
        Descriptors.FileDescriptor fileDescriptor = descriptor.getFile();
        DescriptorProtos.FileOptions options = fileDescriptor.getOptions();
        String packageName = options.hasJavaPackage()
                ? options.getJavaPackage()
                : fileDescriptor.getPackage();
        String outer;
        if (options.hasJavaOuterClassname()) {
            outer = options.getJavaOuterClassname();
        } else {
            outer = new File(fileDescriptor.getName()).getName();
            outer = outer.substring(0, outer.lastIndexOf('.'));
            outer = toCamelCase(outer);
        }
        String className = packageName + "." + outer + "$" + descriptor.getName();
        try {
            return Class.forName(className);
        } catch (ClassNotFoundException e) {
            throw new RuntimeException("Unable to resolve type: " + fileDescriptor.getName(), e);
        }
    }

    /**
     * 读取Protobuf字段属性信息
     *
     * @param propDef Protobuf字段描述
     * @param context 模型转换器上下文
     * @return  属性实体
     */
    private Property readProtoProperty(Descriptors.FieldDescriptor propDef, ModelConverterContext context) {
        Descriptors.FieldDescriptor.Type propType = propDef.getType();
        Property property = null;
        switch (propType) {
            case DOUBLE:
                property = new DoubleProperty();
                break;
            case FLOAT:
                property = new FloatProperty();
                break;
            case INT64:
            case FIXED64:
            case SFIXED64:
            case SINT64:
            case UINT64:
                property = new LongProperty();
                break;
            case UINT32:
            case INT32:
            case FIXED32:
            case SFIXED32:
            case SINT32:
                property = new IntegerProperty();
                break;
            case BOOL:
                property = new BooleanProperty();
                break;
            case STRING:
                property = new StringProperty();
                break;
            case BYTES:
                property = new ByteArrayProperty();
                break;
            case ENUM:
                // Protobuf枚举实值为int类型的number
                Set<String> values = propDef.getEnumType().getValues().stream().map(d -> String.valueOf(d.getNumber())).collect(Collectors.toSet());
                String allowValueString = StringUtils.join(values, ",");
                AllowableEnumValues enumValues = AllowableEnumValues.create(allowValueString);
                property = new IntegerProperty();
                if (enumValues != null) {
                    final Map<PropertyBuilder.PropertyId, Object> args = enumValues.asPropertyArguments();
                    PropertyBuilder.merge(property, args);
                    Set<String> valueDesc = propDef.getEnumType().getValues().stream().map(d -> String.format("%d-%s", d.getNumber(), d.getName())).collect(Collectors.toSet());
                    property.setDescription(StringUtils.join(valueDesc, ", "));
                }
                break;
            case GROUP:
            case MESSAGE:
                Descriptors.Descriptor innerType = propDef.getMessageType();
                if (propDef.isMapField()) {
                    // Map类型
                    Property valueType = readProtoProperty(innerType.getFields().get(1), context);
                    MapProperty mapProperty = new MapProperty();
                    mapProperty.setAdditionalProperties(valueType);
                    property = mapProperty;
                } else {
                    // 其他子类型
                    Class inner = readClassOfDescriptor(innerType);
                    property = context.resolveProperty(inner, null);
                }
                break;
        }
        if (propDef.isRepeated()) {
            // 列表类型
            ArrayProperty array = new ArrayProperty();
            array.setItems(property);
            property = array;
        }
        property.setName(propDef.getName());
        property.setRequired(propDef.isRequired());
        property.setPosition(propDef.getIndex());
        return property;
    }

    private static String toCamelCase(String s){
        String[] parts = s.split("_");
        StringBuilder camelCaseString = new StringBuilder();
        for (String part : parts) {
            camelCaseString.append(cap(part));
        }
        return camelCaseString.toString();
    }

    private static String cap(String s) {
        return s.substring(0, 1).toUpperCase() + s.substring(1).toLowerCase();
    }
}
